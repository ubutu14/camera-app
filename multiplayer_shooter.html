<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multiplayer 2D Shooter</title>
    <!-- Google Fonts: Orbitron for game feel, Lato for readability -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #008cff; /* Brighter blue */
            --secondary-color: #32cd32; /* Lime green */
            --dark-bg: #10101a; /* Even darker background */
            --medium-bg: #202030; /* Darker grey-blue */
            --light-bg: #303045; /* Slightly lighter grey-blue for panels */
            --text-color: #e0e0e0; /* Light grey text */
            --accent-color-gold: #ffeb3b; /* Vibrant gold */
            --accent-color-red: #ef5350; /* Softer red */
            --accent-color-green: #66bb6a; /* Brighter green */
            --border-color: #505060; /* Soft border color */
            --modal-bg: rgba(20, 20, 30, 0.95); /* Semi-transparent dark background for modals */
            --glow-blue: rgba(0, 140, 255, 0.5);
            --glow-green: rgba(50, 205, 50, 0.5);
        }

        body {
            font-family: 'Lato', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            /* Enhanced background with radial gradient for more depth */
            background: radial-gradient(circle at top left, var(--dark-bg) 0%, #08080f 70%);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
            /* Removed overflow: hidden; from here */
        }

        /* Body Fullscreen adjustments - only apply overflow: hidden when in fullscreen */
        html:-webkit-full-screen,
        html:-moz-full-screen,
        html:-ms-full-screen,
        html:fullscreen {
            overflow: hidden; /* Prevent scrolling in fullscreen */
            background: black; /* Solid black background for fullscreen */
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-color-gold);
            /* More pronounced text shadow for a glowing effect */
            text-shadow: 0 0 15px var(--accent-color-gold), 0 0 25px rgba(255, 235, 59, 0.7);
            margin-bottom: 25px; /* Increased margin */
            font-size: 3em; /* Larger title */
            letter-spacing: 2px; /* Slightly more spaced out */
        }

        /* NEW: Game Area Wrapper for responsive canvas */
        #game-area-wrapper {
            position: relative;
            width: 100%; /* Fill parent width (ui-container) */
            max-width: 800px; /* Constrain to original game width */
            aspect-ratio: 4 / 3; /* Maintain 4:3 aspect ratio (800/600) */
            background-color: var(--medium-bg); /* Canvas background on wrapper */
            border: 3px solid var(--border-color); /* Canvas border on wrapper */
            box-shadow: 0 0 25px rgba(0, 140, 255, 0.4), 0 0 50px rgba(0, 140, 255, 0.2); /* Canvas shadow on wrapper */
            border-radius: 12px; /* Canvas border-radius on wrapper */
            margin-bottom: 25px; /* Keep margin here for spacing below game */
            display: flex; /* To center canvas if needed, though canvas will fill it */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide anything that goes outside */
        }

        /* Canvas will fill its responsive parent */
        canvas {
            width: 100%; /* Fill the wrapper's width */
            height: 100%; /* Fill the wrapper's height */
            display: block;
            /* Remove styles that are now on #game-area-wrapper */
            background-color: transparent;
            border: none;
            box-shadow: none;
            margin-bottom: 0;
            border-radius: 0;
        }

        /* Canvas scaling when the *HTML* element is fullscreen */
        html:fullscreen #gameCanvas,
        html:-webkit-full-screen #gameCanvas,
        html:-moz-full-screen #gameCanvas,
        html:-ms-full-screen #gameCanvas {
            max-width: 100vw;
            max-height: 100vh;
            width: auto; /* Allow object-fit to control width */
            height: auto; /* Allow object-fit to control height */
            object-fit: contain; /* Maintain aspect ratio and fit within screen */
            margin: auto; /* Center it in fullscreen */
            position: absolute; /* Position relative to fullscreen body */
            top: 0; bottom: 0; left: 0; right: 0;
            background-color: var(--medium-bg); /* Ensure background is still there */
            /* In fullscreen, wrapper's visual styles are removed, so canvas needs its own here if desired */
            border: none;
            box-shadow: none;
            border-radius: 0;
        }


        .ui-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px; /* Increased gap */
            width: 100%;
            max-width: 800px;
        }

        .panel {
            background-color: var(--light-bg);
            padding: 25px; /* Increased padding */
            border-radius: 12px; /* More rounded */
            /* Enhanced shadow for depth */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4), inset 0 0 5px rgba(255, 255, 255, 0.05);
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
        }

        .panel h2 {
            font-family: 'Orbitron', sans-serif;
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid rgba(255, 255, 255, 0.15); /* Slightly stronger separator */
            padding-bottom: 12px;
            margin-bottom: 20px;
            font-size: 1.8em; /* Larger panel titles */
        }

        .panel p {
            margin-bottom: 12px; /* Adjusted margin */
            line-height: 1.6; /* Improved readability */
            font-size: 1.05em; /* Slightly larger text */
        }

        .panel kbd {
            background-color: #444; /* Darker kbd background */
            padding: 4px 8px; /* Larger padding */
            border-radius: 5px; /* More rounded */
            font-family: 'Share Tech Mono', monospace; /* More techy font for kbd */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: 1px solid #666;
            color: #eee; /* Lighter kbd text */
        }

        /* Buttons & Inputs */
        button {
            font-family: 'Orbitron', sans-serif;
            /* Richer gradient for primary buttons */
            background: linear-gradient(180deg, var(--primary-color) 0%, #0066cc 100%);
            color: white;
            padding: 14px 30px; /* More generous padding */
            border: none;
            border-radius: 8px; /* More rounded */
            cursor: pointer;
            font-size: 1.05em; /* Slightly larger font */
            vertical-align: middle;
            /* Enhanced shadow for depth and glow */
            box-shadow: 0 5px 15px rgba(0, 140, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            transition: all 0.25s ease-in-out; /* Smoother transition */
            text-transform: uppercase;
            letter-spacing: 1.5px; /* More spaced out */
            -webkit-tap-highlight-color: transparent;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5); /* Text shadow for buttons */
        }

        button:hover {
            background: linear-gradient(180deg, #0066cc 0%, #004d99 100%);
            transform: translateY(-3px); /* More pronounced lift */
            box-shadow: 0 8px 20px rgba(0, 140, 255, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type="text"], input[type="color"] {
            background-color: #404055; /* Darker input background */
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 12px 18px; /* More padding */
            border-radius: 8px; /* More rounded */
            font-size: 1.05em; /* Slightly larger font */
            text-align: center;
            width: 180px;
            box-sizing: border-box;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="text"]:focus, input[type="color"]:focus {
            border-color: var(--primary-color);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4), 0 0 8px rgba(0, 140, 255, 0.6);
            outline: none;
        }
        input[type="color"] {
            width: 50px;
            height: 40px; /* Slightly taller */
            padding: 0;
            border: 2px solid var(--border-color); /* Thicker border for color picker */
            cursor: pointer;
            vertical-align: middle;
            border-radius: 6px;
        }

        /* NEW: Slider specific styles */
        input[type="range"] {
            -webkit-appearance: none;
            width: 180px; /* Wider slider */
            height: 10px; /* Thicker track */
            background: #505065; /* Darker track */
            outline: none;
            opacity: 0.9;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px; /* Larger thumb */
            height: 24px;
            border-radius: 50%;
            background: var(--accent-color-gold); /* Gold thumb */
            cursor: pointer;
            box-shadow: 0 0 8px var(--accent-color-gold), 0 0 15px rgba(255, 235, 59, 0.5); /* Glowing thumb */
            border: 2px solid white;
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-color-gold);
            cursor: pointer;
            box-shadow: 0 0 8px var(--accent-color-gold), 0 0 15px rgba(255, 235, 59, 0.5);
            border: 2px solid white;
        }


        .status { color: yellow; }
        .disconnected { color: var(--accent-color-red); }
        .connected { color: var(--accent-color-green); }

        /* Notification Area */
        #notification-area {
            position: absolute;
            top: 25px; /* Slightly more space from top */
            right: 25px; /* Slightly more space from right */
            width: 300px; /* Wider notifications */
            max-height: 85vh; /* More height */
            overflow-y: auto;
            pointer-events: none;
            z-index: 1000;
        }
        .notification {
            background-color: rgba(0, 0, 0, 0.85); /* Darker, more transparent */
            color: white;
            padding: 15px 20px; /* More padding */
            border-radius: 10px; /* More rounded */
            margin-bottom: 15px; /* More space between notifications */
            opacity: 0;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-out;
            transform: translateX(100%);
            /* Enhanced shadow for notifications */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5), inset 0 0 3px rgba(255, 255, 255, 0.05);
            pointer-events: auto;
            font-size: 1em; /* Standard font size */
            border-left: 6px solid; /* Thicker colored border */
        }
        .notification.show { opacity: 1; transform: translateX(0); }
        .notification.hide { opacity: 0; transform: translateX(100%); }
        .notification.info { border-color: var(--primary-color); }
        .notification.success { border-color: var(--accent-color-green); }
        .notification.warning { border-color: #ffc107; } /* Yellowish-orange */
        .notification.error { border-color: var(--accent-color-red); }

        /* Mobile Controls Container - Fixed at bottom of viewport */
        .mobile-controls-container {
            display: none; /* Controlled by JS */
            position: fixed; /* Always relative to viewport */
            bottom: 0; /* Align to very bottom */
            left: 0; /* Align to very left */
            width: 100%; /* Full width */
            height: 100%; /* Full height to allow controls anywhere */
            padding: 0;
            box-sizing: border-box;
            z-index: 900;
            pointer-events: none; /* Allow events to pass through, children will re-enable */
            /* background-color: rgba(255, 0, 0, 0.1); /* Debugging background, uncomment to see the fixed area */
        }
        .mobile-controls-container > div,
        .mobile-controls-container > button { /* Re-enable pointer events for actual controls */
            pointer-events: auto;
        }

        /* Joystick Styles */
        #joystick-base {
            position: absolute; /* Relative to mobile-controls-container */
            /* Initial left/bottom will be set by JS */
            width: 130px; /* Slightly larger base */
            height: 130px;
            border-radius: 50%;
            /* More complex background for frosted glass effect */
            background-color: rgba(255, 255, 255, 0.08); /* More transparent */
            backdrop-filter: blur(8px); /* Frosted glass effect */
            -webkit-backdrop-filter: blur(8px); /* For Safari */
            border: 2px solid rgba(255, 255, 255, 0.2); /* Softer border */
            /* Subtle inner and outer shadow for depth */
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.05), 0 0 20px var(--glow-blue);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #joystick-thumb {
            position: absolute; /* Relative to joystick-base */
            width: 65px; /* Slightly larger thumb */
            height: 65px;
            border-radius: 50%;
            /* Richer gradient for thumb */
            background: linear-gradient(180deg, var(--primary-color) 0%, #0056b3 100%);
            border: 3px solid rgba(255, 255, 255, 0.8); /* Stronger white border */
            /* More prominent shadow and glow */
            box-shadow: 0 0 15px var(--primary-color), 0 0 25px var(--glow-blue);
            cursor: grab;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease; /* Smooth transition */
        }
        #joystick-thumb.active {
            cursor: grabbing;
            box-shadow: 0 0 20px var(--primary-color), 0 0 35px var(--glow-blue); /* Stronger glow when active */
        }

        #shootButton { /* Direct child of mobile-controls-container */
            position: absolute; /* Relative to mobile-controls-container */
            /* Initial right/bottom will be set by JS */
            /* Richer gradient for shoot button */
            background: linear-gradient(180deg, var(--secondary-color) 0%, #228b22 100%); /* Forest green */
            color: white;
            padding: 28px 38px; /* More padding */
            border: none;
            border-radius: 50%;
            font-size: 2.8em; /* Larger X symbol */
            width: 110px; /* Larger button */
            height: 110px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            /* Enhanced shadow and glow */
            box-shadow: 0 8px 20px rgba(50, 205, 50, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            transition: all 0.25s ease-in-out;
            -webkit-tap-highlight-color: transparent;
            text-shadow: 0 1px 3px rgba(0,0,0,0.6); /* Text shadow for X */
        }
        #shootButton:active {
            background: linear-gradient(180deg, #228b22 0%, #1a6b1a 100%);
            transform: scale(0.92); /* Slightly less aggressive scale */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5), inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        #shootButton:hover {
            background: linear-gradient(180deg, #228b22 0%, #1a6b1a 100%);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(50, 205, 50, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Modal / Settings Panel */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Darker overlay */
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px); /* Stronger frosted glass effect */
            -webkit-backdrop-filter: blur(10px); /* For Safari */
        }

        .modal-content {
            background-color: var(--modal-bg);
            margin: auto;
            padding: 35px; /* More padding */
            border: 1px solid var(--border-color);
            border-radius: 15px; /* More rounded */
            width: 85%; /* Slightly wider */
            max-width: 550px; /* Increased max width */
            /* More prominent shadow */
            box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 8px rgba(255,255,255,0.08);
            animation: fadeIn 0.4s ease-out; /* Slightly longer fade in */
            position: relative;
            text-align: center;
        }

        .modal-content h3 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-color-gold);
            text-shadow: 0 0 8px rgba(255, 235, 59, 0.5); /* Subtle glow */
            margin-top: 0;
            margin-bottom: 30px; /* More space */
            font-size: 2em; /* Larger heading */
            letter-spacing: 1px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 8px; /* Adjusted margin */
            font-size: 1.15em; /* Larger label font */
            color: var(--text-color);
            font-weight: 300; /* Lighter font weight for labels */
        }

        .modal-content .setting-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px; /* Increased gap */
            margin-bottom: 25px; /* More space between rows */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        .modal-content .setting-row label {
            margin-bottom: 0;
            flex-basis: 120px; /* Give labels a fixed width */
            text-align: right;
        }
        .modal-content .setting-row input {
            flex-grow: 1; /* Inputs can grow */
            max-width: 200px; /* Max width for inputs */
        }

        .modal-content button {
            margin-top: 20px; /* More space above buttons */
            width: auto;
        }

        .close-button {
            color: #ccc; /* Lighter close button */
            position: absolute;
            top: 20px; /* More space */
            right: 30px; /* More space */
            font-size: 35px; /* Larger close button */
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease, transform 0.2s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--accent-color-red);
            transform: scale(1.1); /* Slight scale on hover */
            text-decoration: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-30px); } /* More pronounced animation */
            to { opacity: 1; transform: translateY(0); }
        }

        /* Scoreboard */
        #scoreboard {
            position: absolute;
            top: 25px; /* Consistent spacing with notifications */
            left: 25px;
            background-color: rgba(20, 20, 30, 0.85); /* Darker, more opaque */
            padding: 20px; /* More padding */
            border-radius: 10px;
            /* Enhanced shadow */
            box-shadow: 0 5px 15px rgba(0,0,0,0.4), inset 0 0 5px rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            max-height: 75vh; /* Increased max height */
            overflow-y: auto;
            width: 220px; /* Wider scoreboard */
            text-align: left;
        }
        #scoreboard h3 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-color-gold);
            text-shadow: 0 0 5px rgba(255, 235, 59, 0.3);
            margin-top: 0;
            margin-bottom: 15px; /* More space */
            font-size: 1.3em; /* Slightly larger title */
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15); /* Stronger separator */
            padding-bottom: 10px;
        }
        #scoreboard ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #scoreboard li {
            padding: 8px 0; /* More padding */
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95em; /* Slightly larger text */
            border-bottom: 1px dashed rgba(255, 255, 255, 0.08); /* Softer dashed line */
            transition: background-color 0.2s ease;
        }
        #scoreboard li:hover {
            background-color: rgba(255, 255, 255, 0.05); /* Subtle hover effect */
        }
        #scoreboard li:last-child {
            border-bottom: none;
        }
        #scoreboard .player-name {
            font-weight: 700; /* Bolder name */
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 65%; /* Limit name width */
        }
        #scoreboard .player-score {
            font-family: 'Orbitron', sans-serif; /* Score in Orbitron */
            color: var(--accent-color-gold);
            text-shadow: 0 0 5px rgba(255, 235, 59, 0.3);
            font-size: 1.1em; /* Slightly larger score */
        }
        #scoreboard li.local-player .player-name {
            color: var(--accent-color-gold); /* Highlight local player */
        }

        /* General layout adjustments */
        .game-controls {
            display: flex;
            gap: 20px; /* More space */
            justify-content: center;
            margin-bottom: 20px; /* More space */
        }
        .game-controls button {
            width: 200px; /* Wider buttons */
        }

        .info-panel {
            margin-top: 25px; /* More space */
            text-align: left;
            width: 100%;
        }
        .info-panel .status-line {
            text-align: center;
            margin-bottom: 15px; /* More space */
            font-size: 1.2em; /* Larger status text */
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-color);
        }

        /* Hide elements if JS is disabled */
        noscript {
            display: block;
            text-align: center;
            color: red;
            font-size: 1.2em;
            margin-top: 20px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body { padding: 10px; } /* Less overall padding on small screens */
            h1 { font-size: 2.2em; margin-bottom: 15px; }
            /* #game-area-wrapper and canvas handled by new responsive rules */
            .ui-container { gap: 10px; }
            .panel { padding: 15px; border-radius: 8px; }
            .panel h2 { font-size: 1.5em; margin-bottom: 15px; }
            .panel p { font-size: 0.95em; }
            button { padding: 10px 20px; font-size: 0.95em; border-radius: 6px; }
            input[type="text"], input[type="color"] { padding: 8px 12px; font-size: 0.95em; border-radius: 6px; }
            input[type="range"] { width: 120px; height: 6px; } /* Smaller sliders */
            input[type="range"]::-webkit-slider-thumb,
            input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; }

            #notification-area { top: 10px; right: 10px; width: 200px; padding: 10px 15px; font-size: 0.85em; border-radius: 8px; }
            .notification { margin-bottom: 10px; }

            #joystick-base { width: 100px; height: 100px; } /* Smaller joystick */
            #joystick-thumb { width: 50px; height: 50px; }
            #shootButton { width: 90px; height: 90px; font-size: 2.2em; padding: 20px; } /* Smaller shoot button */

            .mobile-controls-container {
                /* Adjust positioning to be closer to edges on small screens */
                bottom: 10px;
                left: 10px;
                width: calc(100% - 20px);
                height: calc(100% - 20px); /* Still full height for flexible positioning */
            }

            #scoreboard { top: 10px; left: 10px; width: 160px; padding: 15px; font-size: 0.85em; border-radius: 8px; }
            #scoreboard h3 { font-size: 1.1em; margin-bottom: 10px; }
            #scoreboard li { padding: 5px 0; font-size: 0.8em; }

            .modal-content { width: 95%; padding: 20px; border-radius: 10px; }
            .modal-content h3 { font-size: 1.6em; margin-bottom: 20px; }
            .modal-content label { font-size: 1em; }
            .modal-content .setting-row { flex-direction: column; gap: 10px; margin-bottom: 15px; }
            .modal-content .setting-row label { text-align: center; flex-basis: auto; }
            .modal-content .setting-row input { max-width: 100%; }
            .close-button { top: 10px; right: 15px; font-size: 30px; }
        }
    </style>
</head>
<body>
    <div id="notification-area"></div>
    <div id="scoreboard">
        <h3>SCOREBOARD</h3>
        <ul id="playerScoresList">
            <!-- Scores will be dynamically inserted here -->
        </ul>
    </div>

    <h1>Multiplayer 2D Shooter</h1>

    <div class="ui-container">
        <div class="game-controls">
            <button id="openSettingsButton">Settings</button>
            <button id="fullscreenButton">Toggle Fullscreen</button>
        </div>
    
        <!-- Game Canvas Area - now responsive -->
        <div id="game-area-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
    
        <div class="info-panel panel">
            <h2 class="status-line">Game Status: <span id="connectionStatus" class="disconnected">Disconnected</span></h2>
            <p>This is a **client-side demonstration** of a multiplayer game concept, powered by WebSockets.</p>
            <p>A **real multiplayer game** requires a dedicated **server** to manage game logic, player synchronization, and communication between all clients.</p>
            <p class="controls-info"><strong>Controls:</strong>
                <br>Move: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> or <kbd>Arrow Keys</kbd> / **On-screen Joystick**
                <br>Shoot: <kbd>Spacebar</kbd> / **On-screen <kbd>X</kbd> button**
            </p>
        </div>
    </div>

    <!-- Mobile Controls (Joystick and Shoot Button) - NOW A DIRECT CHILD OF BODY -->
    <div class="mobile-controls-container">
        <div id="joystick-base">
            <div id="joystick-thumb"></div>
        </div>
        <!-- Shoot button directly, not wrapped in action-buttons div for simplicity -->
        <button id="shootButton">X</button> 
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeSettingsButton">&times;</span>
            <h3>Game Settings</h3>
            
            <div class="setting-row">
                <label for="playerNameInput">Your Name:</label>
                <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="12">
                <button id="setPlayerNameButton">Save Name</button>
            </div>

            <div class="setting-row">
                <label for="playerColorInput">Your Color:</label>
                <input type="color" id="playerColorInput">
                <button id="setPlayerColorButton">Set Color</button>
            </div>

            <!-- NEW: Joystick Position Settings -->
            <h3>Touch Controls Position</h3>
            <div class="setting-row">
                <label for="joystickX">Joystick X (from Left):</label>
                <input type="range" id="joystickX" min="0" max="300" value="20">
                <span id="joystickXValue">20</span>px
            </div>
            <div class="setting-row">
                <label for="joystickY">Joystick Y (from Bottom):</label>
                <input type="range" id="joystickY" min="0" max="300" value="20">
                <span id="joystickYValue">20</span>px
            </div>

            <!-- NEW: Shoot Button Position Settings -->
            <div class="setting-row">
                <label for="shootButtonX">Shoot Btn X (from Right):</label>
                <input type="range" id="shootButtonX" min="0" max="300" value="20">
                <span id="shootButtonXValue">20</span>px
            </div>
            <div class="setting-row">
                <label for="shootButtonY">Shoot Btn Y (from Bottom):</label>
                <input type="range" id="shootButtonY" min="0" max="300" value="20">
                <span id="shootButtonYValue">20</span>px
            </div>

            <button id="saveControlPositionsButton">Save Control Positions</button>
            <button id="resetControlPositionsButton">Reset Control Defaults</button>

            <p style="font-size: 0.9em; color: #aaa; margin-top: 25px;">More settings coming soon!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const connectionStatusSpan = document.getElementById('connectionStatus');
        const fullscreenButton = document.getElementById('fullscreenButton');
        const playerNameInput = document.getElementById('playerNameInput');
        const setPlayerNameButton = document.getElementById('setPlayerNameButton');
        const playerColorInput = document.getElementById('playerColorInput'); 
        const setPlayerColorButton = document.getElementById('setPlayerColorButton'); 
        const notificationArea = document.getElementById('notification-area');
        const settingsModal = document.getElementById('settingsModal'); 
        const openSettingsButton = document.getElementById('openSettingsButton'); 
        const closeSettingsButton = document.getElementById('closeSettingsButton'); 
        const playerScoresList = document.getElementById('playerScoresList'); 

        // Reference to the new wrapper for canvas
        const gameAreaWrapper = document.getElementById('game-area-wrapper');
        // Mobile controls container (now a direct child of body)
        const mobileControlsContainer = document.querySelector('.mobile-controls-container'); 

        // Joystick elements
        const joystickBase = document.getElementById('joystick-base');
        const joystickThumb = document.getElementById('joystick-thumb');
        const shootButton = document.getElementById('shootButton');

        // NEW: Control position input elements
        const joystickXInput = document.getElementById('joystickX');
        const joystickYInput = document.getElementById('joystickY');
        const shootButtonXInput = document.getElementById('shootButtonX');
        const shootButtonYInput = document.getElementById('shootButtonY');
        const joystickXValueSpan = document.getElementById('joystickXValue');
        const joystickYValueSpan = document.getElementById('joystickYValue');
        const shootButtonXValueSpan = document.getElementById('shootButtonXValue');
        const shootButtonYValueSpan = document.getElementById('shootButtonYValue');
        const saveControlPositionsButton = document.getElementById('saveControlPositionsButton');
        const resetControlPositionsButton = document.getElementById('resetControlPositionsButton');


        const PLAYER_SPEED = 3; 
        const BULLET_SPEED = 10;
        const PLAYER_RADIUS = 15;
        const BULLET_RADIUS = 3;
        const BULLET_LIFETIME = 60; 
        const MUZZLE_FLASH_DURATION = 5; 
        const HIT_MARKER_DURATION = 15; 
        const PLAYER_HIT_FLASH_DURATION = 10; 
        const NOTIFICATION_DISPLAY_TIME = 3000; 
        const INITIAL_MAX_HEALTH_CLIENT = 100; 

        // Load or generate player name and color
        let defaultPlayerName = localStorage.getItem('playerName') || 'Player_' + Math.floor(Math.random() * 1000);
        let defaultPlayerColor = localStorage.getItem('playerColor') || `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`; 
        
        playerNameInput.value = defaultPlayerName;
        playerColorInput.value = defaultPlayerColor;

        let localPlayer = {
            id: defaultPlayerName,
            x: canvas.width / 2,
            y: canvas.height / 2,
            color: defaultPlayerColor, 
            health: INITIAL_MAX_HEALTH_CLIENT,
            maxHealth: INITIAL_MAX_HEALTH_CLIENT, 
            score: 0,
            lastShotTime: 0,
            shootCooldown: 200, 
            muzzleFlashTimer: 0,
            hitFlashTimer: 0
        };

        let otherPlayers = {}; 
        let keys = {}; // For keyboard input
        let bullets = []; 

        let muzzleFlashes = [];
        let hitMarkers = [];
        let particles = [];

        // Joystick state
        let joystickActive = false;
        let joystickTouchIdentifier = null; // To track multi-touch
        const joystickMaxRadius = 40; // Max distance thumb can move from center
        let joystickDx = 0;
        let joystickDy = 0;

        // NEW: Default and current control position settings
        const DEFAULT_CONTROL_POSITIONS = {
            joystick: { x: 40, y: 40 }, // Offset from left, bottom (adjusted for larger joystick)
            shootButton: { x: 40, y: 40 } // Offset from right, bottom (adjusted for larger button)
        };
        let currentControlPositions = JSON.parse(localStorage.getItem('controlPositions')) || DEFAULT_CONTROL_POSITIONS;


        class Particle {
            constructor(x, y, color, size, speedX, speedY, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.speedX = speedX;
                this.speedY = speedY;
                this.life = life;
                this.opacity = 1;
                this.decay = 1 / life;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.opacity -= this.decay;
                this.life--;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.opacity);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function showNotification(message, type = 'info', duration = NOTIFICATION_DISPLAY_TIME) {
            const notificationDiv = document.createElement('div');
            notificationDiv.classList.add('notification', type);
            notificationDiv.textContent = message;
            notificationArea.prepend(notificationDiv);

            setTimeout(() => notificationDiv.classList.add('show'), 10);

            setTimeout(() => {
                notificationDiv.classList.remove('show');
                notificationDiv.classList.add('hide');
                notificationDiv.addEventListener('transitionend', () => {
                    notificationDiv.remove();
                }, { once: true });
            }, duration);
        }

        let ws;

        function connectToServer() {
            const WEBSOCKET_URL = 'wss://game.meho.dpdns.org';

            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                console.log('Connected to WebSocket server.');
                connectionStatusSpan.textContent = 'Connected';
                connectionStatusSpan.className = 'connected';
                // Send player data including color on join
                ws.send(JSON.stringify({ type: 'player_join', player: {
                    id: localPlayer.id,
                    x: localPlayer.x,
                    y: localPlayer.y,
                    color: localPlayer.color 
                }}));
                showNotification(`Connected! Welcome, ${localPlayer.id}!`, 'success');
            };


            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                // console.log('Client received:', message); 

                switch (message.type) {
                    case 'player_id_confirmed':
                        const oldId = localPlayer.id;
                        if (message.id !== localPlayer.id) {
                            localPlayer.id = message.id; 
                            showNotification(`Your name was updated to: ${localPlayer.id} (was ${oldId})`, 'success');
                        } else {
                            showNotification(`Successfully joined as ${localPlayer.id}!`, 'success');
                        }
                        if(playerNameInput.value === oldId || oldId.startsWith('Player_')) {
                            playerNameInput.value = localPlayer.id;
                            localStorage.setItem('playerName', localPlayer.id);
                        }
                        break;

                    case 'game_state_update':
                        const serverPlayers = message.players || {};

                        for (const id in serverPlayers) {
                            if (id !== localPlayer.id && !otherPlayers[id]) {
                                showNotification(`${serverPlayers[id].id || id} joined the game.`, 'info');
                            }
                        }
                        for (const id in otherPlayers) {
                            if (!serverPlayers[id]) {
                                showNotification(`${otherPlayers[id].id || id} left the game.`, 'warning');
                            }
                        }

                        // --- Update Local Player ---
                        if (serverPlayers[localPlayer.id]) {
                            const serverLocalData = serverPlayers[localPlayer.id];
                            localPlayer.x = serverLocalData.x;
                            localPlayer.y = serverLocalData.y;

                            if (localPlayer.health !== serverLocalData.health) {
                                if (localPlayer.health > serverLocalData.health) { 
                                    localPlayer.hitFlashTimer = PLAYER_HIT_FLASH_DURATION; 
                                }
                                if (localPlayer.health <=0 && serverLocalData.health === serverLocalData.maxHealth) { 
                                    showNotification('You respawned!', 'success');
                                }
                                localPlayer.health = serverLocalData.health;
                            }
                            localPlayer.score = serverLocalData.score;
                            localPlayer.maxHealth = serverLocalData.maxHealth; 
                            localPlayer.color = serverLocalData.color; 
                        }

                        // --- Update Other Players ---
                        const newOtherPlayers = {};
                        for (const id in serverPlayers) {
                            if (id !== localPlayer.id) {
                                newOtherPlayers[id] = { ...serverPlayers[id] }; 

                                const prevOtherPlayerState = otherPlayers[id]; 

                                newOtherPlayers[id]._prevHealth = prevOtherPlayerState ? prevOtherPlayerState.health : newOtherPlayers[id].health;
                                newOtherPlayers[id].hitFlashTimer = prevOtherPlayerState ? prevOtherPlayerState.hitFlashTimer : 0; 

                                if (newOtherPlayers[id].health < newOtherPlayers[id]._prevHealth) { 
                                    if (newOtherPlayers[id].health <= 0) {
                                    } else {
                                    }
                                }
                                if (newOtherPlayers[id]._prevHealth <=0 && newOtherPlayers[id].health === newOtherPlayers[id].maxHealth) { 
                                    showNotification(`${newOtherPlayers[id].id} respawned!`, 'info');
                                    newOtherPlayers[id].hitFlashTimer = 0; 
                                }
                            }
                        }
                        otherPlayers = newOtherPlayers;
                        bullets = message.bullets || []; 
                        
                        updateScoreboard(); 
                        break;

                    case 'player_hit': 
                        const targetPlayer = message.id === localPlayer.id ? localPlayer : otherPlayers[message.id];
                        if (targetPlayer) {
                            targetPlayer.hitFlashTimer = PLAYER_HIT_FLASH_DURATION;
                            createImpactParticles(message.hitX || targetPlayer.x, message.hitY || targetPlayer.y, targetPlayer.color);

                            const shooterName = message.shooterId ? (serverPlayers[message.shooterId]?.id || message.shooterId) : 'someone';

                            if (message.id === localPlayer.id) {
                                if (message.newHealth <= 0 && localPlayer.health > 0) { 
                                    showNotification(`You were defeated by ${shooterName}!`, 'error');
                                } else if (localPlayer.health > 0 && message.newHealth < localPlayer.health) {
                                    showNotification(`You were hit by ${shooterName}!`, 'warning', 1500);
                                }
                            } else {
                                if (message.newHealth <= 0 && targetPlayer.health > 0) {
                                    showNotification(`${targetPlayer.id} was defeated by ${shooterName}!`, 'error');
                                } else if (targetPlayer.health > 0 && message.newHealth < targetPlayer.health) {
                                    showNotification(`${targetPlayer.id} was hit by ${shooterName}!`, 'warning', 1500);
                                }
                            }
                        }
                        if (message.hitX && message.hitY) { 
                            hitMarkers.push({ x: message.hitX, y: message.y, timer: HIT_MARKER_DURATION }); 
                        }
                        break;

                    case 'player_upgraded_health': 
                        const upgradedPlayer = message.id === localPlayer.id ? localPlayer : otherPlayers[message.id];
                        if (upgradedPlayer) {
                            const playerName = upgradedPlayer.id;
                            showNotification(`${playerName} achieved ${message.score} score and gained extra health!`, 'success', 4000);
                            if (message.id === localPlayer.id) {
                                localPlayer.maxHealth = message.newMaxHealth;
                            } else if (otherPlayers[message.id]) {
                                otherPlayers[message.id].maxHealth = message.newMaxHealth;
                            }
                        }
                        break;

                    case 'player_joined': 
                        if (message.player && message.player.id !== localPlayer.id) {
                            if (!otherPlayers[message.player.id]) { 
                                otherPlayers[message.player.id] = { ...message.player };
                                otherPlayers[message.player.id].hitFlashTimer = 0; 
                                showNotification(`${message.player.id} joined the game.`, 'info');
                            }
                        }
                        break;

                    case 'player_disconnected':
                        if (message.id && otherPlayers[message.id]) {
                            showNotification(`${otherPlayers[message.id].id} left the game.`, 'warning');
                            delete otherPlayers[message.id];
                        }
                        break;
                }
            };

            ws.onclose = (event) => {
                console.log('Disconnected from WebSocket server. Attempting to reconnect in 3s...', event.reason, event.code);
                connectionStatusSpan.textContent = 'Disconnected';
                connectionStatusSpan.className = 'disconnected';
                showNotification('Disconnected. Reconnecting...', 'error');
                otherPlayers = {};
                bullets = [];
                setTimeout(connectToServer, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                connectionStatusSpan.textContent = 'Error';
                connectionStatusSpan.className = 'disconnected';
                showNotification('WebSocket connection error!', 'error');
                if (ws && ws.readyState !== WebSocket.CLOSED) {
                    ws.close(); 
                }
            };
        }

        document.addEventListener('DOMContentLoaded', connectToServer);

        function createMuzzleFlash(x, y, color) {
            muzzleFlashes.push({ x, y, color, timer: MUZZLE_FLASH_DURATION });
        }

        function createImpactParticles(x, y, baseColor) {
            const numParticles = 10 + Math.floor(Math.random() * 5);
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const speedX = Math.cos(angle) * speed;
                const speedY = Math.sin(angle) * speed;
                const size = Math.random() * 2 + 1;
                const life = Math.random() * 30 + 20;
                let particleColor = baseColor; 
                try {
                    if (baseColor.startsWith('#')) {
                        let r = parseInt(baseColor.substring(1, 3), 16);
                        let g = parseInt(baseColor.substring(3, 5), 16);
                        let b = parseInt(baseColor.substring(5, 7), 16);
                        r = Math.min(255, r + Math.floor(Math.random() * 40 - 20));
                        g = Math.min(255, g + Math.floor(Math.random() * 40 - 20));
                        b = Math.min(255, b + Math.floor(Math.random() * 40 - 20));
                        particleColor = `rgba(${r}, ${g}, ${b}, ${Math.random() * 0.5 + 0.5})`;
                    } else { 
                        particleColor = baseColor;
                    }
                } catch(e) { }
                particles.push(new Particle(x, y, particleColor, size, speedX, speedY, life));
            }
        }

        function update() {
            let dx = 0; 
            let dy = 0; 

            // Only use joystick input if on a touch device and joystick is active
            if (isTouchDevice() && joystickActive) {
                dx = joystickDx * PLAYER_SPEED;
                dy = joystickDy * PLAYER_SPEED;
            } else { // Use keyboard input for non-touch devices or when joystick isn't active
                if (keys['arrowup'] || keys['w']) { dy -= PLAYER_SPEED; }
                if (keys['arrowdown'] || keys['s']) { dy += PLAYER_SPEED; }
                if (keys['arrowleft'] || keys['a']) { dx -= PLAYER_SPEED; }
                if (keys['arrowright'] || keys['d']) { dx += PLAYER_SPEED; }
            }

            if (dx !== 0 && dy !== 0) {
                const length = Math.sqrt(dx * dx + dy * dy);
                dx = (dx / length) * PLAYER_SPEED;
                dy = (dy / length) * PLAYER_SPEED;
            }

            if (dx !== 0 || dy !== 0) {
                localPlayer.x += dx;
                localPlayer.y += dy;
            }

            localPlayer.x = Math.max(PLAYER_RADIUS, Math.min(canvas.width - PLAYER_RADIUS, localPlayer.x));
            localPlayer.y = Math.max(PLAYER_RADIUS, Math.min(canvas.height - PLAYER_RADIUS, localPlayer.y));

            if (ws && ws.readyState === WebSocket.OPEN && (dx !== 0 || dy !== 0)) {
                ws.send(JSON.stringify({ type: 'player_input', dx: dx, dy: dy }));
            }

            // Shoot logic for both keyboard and touch
            if (keys[' '] && (Date.now() - localPlayer.lastShotTime > localPlayer.shootCooldown)) {
                localPlayer.lastShotTime = Date.now();
                createMuzzleFlash(localPlayer.x, localPlayer.y, localPlayer.color);

                let bulletDirX = 0;
                let bulletDirY = -1; // Default: shoot upwards (like a top-down shooter)

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'player_shoot', bulletDirX: bulletDirX, bulletDirY: bulletDirY }));
                }
            }

            for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
                muzzleFlashes[i].timer--;
                if (muzzleFlashes[i].timer <= 0) { muzzleFlashes.splice(i, 1); }
            }
            for (let i = hitMarkers.length - 1; i >= 0; i--) {
                hitMarkers[i].timer--;
                if (hitMarkers[i].timer <= 0) { hitMarkers.splice(i, 1); }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) { particles.splice(i, 1); }
            }
            if (localPlayer.hitFlashTimer > 0) { localPlayer.hitFlashTimer--; }
            for (const id in otherPlayers) {
                if (otherPlayers[id].hitFlashTimer > 0) { otherPlayers[id].hitFlashTimer--; }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, BULLET_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = bullet.color;
                ctx.fill();

                const trailLength = BULLET_SPEED * 1.5;
                ctx.beginPath();
                ctx.moveTo(bullet.x, bullet.y);
                ctx.lineTo(bullet.x - bullet.dirX * trailLength, bullet.y - bullet.dirY * trailLength);
                ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                ctx.lineWidth = BULLET_RADIUS;
                ctx.stroke();
            });

            muzzleFlashes.forEach(flash => {
                const opacity = flash.timer / MUZZLE_FLASH_DURATION;
                ctx.save();
                ctx.globalAlpha = opacity * 0.8;
                ctx.fillStyle = `rgba(255, 223, 0, ${opacity})`; 
                ctx.beginPath();
                const flashSize = PLAYER_RADIUS * (0.6 + (1 - opacity) * 0.4);
                ctx.arc(flash.x, flash.y, flashSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            for (const id in otherPlayers) {
                const player = otherPlayers[id];
                ctx.save();
                if (player.hitFlashTimer > 0) {
                    const flashOpacity = (player.hitFlashTimer / PLAYER_HIT_FLASH_DURATION) * 0.7;
                    ctx.fillStyle = `rgba(255, 0, 0, ${flashOpacity})`; 
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, PLAYER_RADIUS + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.beginPath();
                ctx.arc(player.x, player.y, PLAYER_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = '#ddd'; 
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();

                // Health bar
                ctx.fillStyle = '#555'; 
                ctx.fillRect(player.x - PLAYER_RADIUS, player.y - PLAYER_RADIUS - 12, PLAYER_RADIUS * 2, 6);
                const healthPercentage = Math.max(0, player.health / player.maxHealth);
                ctx.fillStyle = healthPercentage > 0.3 ? 'limegreen' : 'red';
                ctx.fillRect(player.x - PLAYER_RADIUS, player.y - PLAYER_RADIUS - 12, PLAYER_RADIUS * 2 * healthPercentage, 6);

                // Name and Score
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${player.id} (S: ${player.score})`, player.x, player.y + PLAYER_RADIUS + 12);
            }

            // Draw local player
            ctx.save();
            if (localPlayer.hitFlashTimer > 0) {
                const flashOpacity = (localPlayer.hitFlashTimer / PLAYER_HIT_FLASH_DURATION) * 0.8;
                ctx.fillStyle = `rgba(255, 100, 100, ${flashOpacity})`; 
                ctx.beginPath();
                ctx.arc(localPlayer.x, localPlayer.y, PLAYER_RADIUS + 4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.beginPath();
            ctx.arc(localPlayer.x, localPlayer.y, PLAYER_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = localPlayer.color;
            ctx.fill();
            ctx.strokeStyle = 'gold'; 
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();

            // Local player health bar
            ctx.fillStyle = '#555';
            ctx.fillRect(localPlayer.x - PLAYER_RADIUS, localPlayer.y - PLAYER_RADIUS - 12, PLAYER_RADIUS * 2, 6);
            const localHealthPercentage = Math.max(0, localPlayer.health / localPlayer.maxHealth);
            ctx.fillStyle = localHealthPercentage > 0.3 ? 'limegreen' : 'red';
            ctx.fillRect(localPlayer.x - PLAYER_RADIUS, localPlayer.y - PLAYER_RADIUS - 12, PLAYER_RADIUS * 2 * localHealthPercentage, 6);

            // Local player name and score
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`You: ${localPlayer.id} (Score: ${localPlayer.score})`, localPlayer.x, localPlayer.y + PLAYER_RADIUS + 15);


            // Draw hit markers
            hitMarkers.forEach(marker => {
                const opacity = marker.timer / HIT_MARKER_DURATION;
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.strokeStyle = `rgba(255, 50, 50, ${opacity * 0.8})`; 
                ctx.lineWidth = 3;
                const size = 8 + (1 - opacity) * 5; 
                ctx.beginPath();
                ctx.moveTo(marker.x - size / 2, marker.y - size / 2);
                ctx.lineTo(marker.x + size / 2, marker.y + size / 2);
                ctx.moveTo(marker.x + size / 2, marker.y - size / 2);
                ctx.lineTo(marker.x - size / 2, marker.y + size / 2);
                ctx.stroke();
                ctx.restore();
            });

            // Draw particles
            particles.forEach(p => p.draw(ctx));
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        gameLoop();

        // --- Scoreboard Update Function ---
        function updateScoreboard() {
            const allPlayers = Object.values(otherPlayers).concat(localPlayer);
            allPlayers.sort((a, b) => b.score - a.score);

            playerScoresList.innerHTML = ''; 

            allPlayers.forEach(player => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `<span class="player-name" style="color: ${player.color};">${player.id}</span> <span class="player-score">${player.score}</span>`;
                if (player.id === localPlayer.id) {
                    listItem.classList.add('local-player'); 
                }
                playerScoresList.appendChild(listItem);
            });
        }

        // Function to detect if the device is a touch device (more robust)
        function isTouchDevice() {
            return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0) || window.matchMedia('(pointer: coarse)').matches;
        }

        // Function to update the visibility of mobile controls
        // This will be called once on DOMContentLoaded to set initial state
        function updateMobileControlsVisibility() {
            if (isTouchDevice()) {
                mobileControlsContainer.style.display = 'block'; // Use block as children are absolute
            } else {
                mobileControlsContainer.style.display = 'none';
            }
        }

        // NEW: Function to apply control positions based on currentControlPositions
        function applyControlPositions() {
            joystickBase.style.left = `${currentControlPositions.joystick.x}px`;
            joystickBase.style.bottom = `${currentControlPositions.joystick.y}px`;
            // For shoot button, we use right offset
            shootButton.style.right = `${currentControlPositions.shootButton.x}px`; 
            shootButton.style.bottom = `${currentControlPositions.shootButton.y}px`;
        }

        // NEW: Function to update settings modal sliders and spans
        function updateSettingsUI() {
            joystickXInput.value = currentControlPositions.joystick.x;
            joystickYInput.value = currentControlPositions.joystick.y;
            shootButtonXInput.value = currentControlPositions.shootButton.x;
            shootButtonYInput.value = currentControlPositions.shootButton.y;

            joystickXValueSpan.textContent = currentControlPositions.joystick.x;
            joystickYValueSpan.textContent = currentControlPositions.joystick.y;
            shootButtonXValueSpan.textContent = currentControlPositions.shootButton.x;
            shootButtonYValueSpan.textContent = currentControlPositions.shootButton.y;
        }

        // --- Input Handling (Keyboard) ---
        window.addEventListener('keydown', (e) => {
            // Only process keyboard if not on a touch device
            if (!isTouchDevice()) {
                const key = e.key.toLowerCase();
                keys[key] = true;
                if (key === ' ' || key.startsWith('arrow') || ['w', 'a', 's', 'd'].includes(key)) {
                    e.preventDefault();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (!isTouchDevice()) { // Only process keyboard if not on a touch device
                keys[e.key.toLowerCase()] = false;
            }
        });

        // --- Joystick Input Handling ---
        const getTouchOrMousePos = (e) => {
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
            return { clientX, clientY };
        };

        const handleJoystickStart = (e) => {
            if (!isTouchDevice()) return; // Only for touch devices

            // Prevent multiple touches from activating multiple joysticks or conflicting
            if (e.type === 'touchstart' && e.touches.length > 1) {
                return; 
            }

            // If a touch is already being tracked, ignore new touches
            if (joystickActive && joystickTouchIdentifier !== null) {
                return;
            }

            e.preventDefault();
            joystickActive = true;
            joystickThumb.classList.add('active'); // Add active class for styling
            joystickThumb.style.transition = 'none'; // Disable transition during drag

            if (e.touches && e.touches.length > 0) {
                joystickTouchIdentifier = e.touches[0].identifier; // Track the specific touch
            }

            const baseRect = joystickBase.getBoundingClientRect();
            const startPos = getTouchOrMousePos(e);
            
            // Calculate initial position relative to joystickBase center
            let x = startPos.clientX - baseRect.left - baseRect.width / 2;
            let y = startPos.clientY - baseRect.top - baseRect.height / 2;

            const distance = Math.sqrt(x * x + y * y);
            if (distance > joystickMaxRadius) {
                const angle = Math.atan2(y, x);
                x = Math.cos(angle) * joystickMaxRadius;
                y = Math.sin(angle) * joystickMaxRadius;
            }
            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;

            joystickDx = x / joystickMaxRadius;
            joystickDy = y / joystickMaxRadius;
        };

        const handleJoystickMove = (e) => {
            if (!joystickActive || !isTouchDevice()) return;
            
            // For touchmove, ensure we're tracking the correct touch
            let touch = null;
            if (e.touches) {
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === joystickTouchIdentifier) {
                        touch = e.touches[i];
                        break;
                    }
                }
                if (!touch) return; // Not the touch we're tracking
            }

            e.preventDefault();

            const baseRect = joystickBase.getBoundingClientRect();
            const currentPos = getTouchOrMousePos(e);
            
            let x = currentPos.clientX - baseRect.left - baseRect.width / 2;
            let y = currentPos.clientY - baseRect.top - baseRect.height / 2;

            const distance = Math.sqrt(x * x + y * y);

            if (distance > joystickMaxRadius) {
                const angle = Math.atan2(y, x);
                x = Math.cos(angle) * joystickMaxRadius;
                y = Math.sin(angle) * joystickMaxRadius;
            }

            joystickThumb.style.transform = `translate(${x}px, ${y}px)`;
            joystickDx = x / joystickMaxRadius;
            joystickDy = y / joystickMaxRadius;
        };

        const handleJoystickEnd = (e) => {
            if (!joystickActive || !isTouchDevice()) return;

            // For touchend/touchcancel, ensure we're ending the correct touch
            let touchEnded = false;
            if (e.changedTouches) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchIdentifier) {
                        touchEnded = true;
                        break;
                    }
                }
                if (!touchEnded) return; // Not the touch we're tracking that ended
            }

            joystickActive = false;
            joystickTouchIdentifier = null;
            joystickThumb.classList.remove('active'); // Remove active class
            joystickThumb.style.transition = 'transform 0.1s ease-out'; // Re-enable transition
            joystickThumb.style.transform = 'translate(0, 0)'; // Reset thumb to center
            joystickDx = 0;
            joystickDy = 0;
        };
        
        // Use consistent event names for touch and mouse
        const startEvent = 'ontouchstart' in window ? 'touchstart' : 'mousedown';
        const moveEvent = 'ontouchmove' in window ? 'touchmove' : 'mousemove';
        const endEvent = 'ontouchend' in window ? 'touchend' : 'mouseup';
        const cancelEvent = 'ontouchcancel' in window ? 'touchcancel' : 'mouseleave'; // For touch cancel or mouse leaving element

        joystickBase.addEventListener(startEvent, handleJoystickStart, { passive: false });
        document.addEventListener(moveEvent, handleJoystickMove, { passive: false });
        document.addEventListener(endEvent, handleJoystickEnd, { passive: false });
        document.addEventListener(cancelEvent, handleJoystickEnd, { passive: false }); // Handle touch cancellation

        // Shoot button for touch devices
        shootButton.addEventListener(startEvent, (e) => {
            if (!isTouchDevice()) return; // Only for touch devices
            e.preventDefault();
            keys[' '] = true; // Simulate spacebar press
        }, { passive: false });

        shootButton.addEventListener(endEvent, (e) => {
            if (!isTouchDevice()) return; // Only for touch devices
            e.preventDefault();
            keys[' '] = false; // Simulate spacebar release
        });
        shootButton.addEventListener(cancelEvent, (e) => {
            if (!isTouchDevice()) return; // Only for touch devices
            keys[' '] = false; // Release if touch is cancelled/leaves
        });


        // --- Fullscreen Toggle ---
        function toggleFullscreen() {
            // Target the entire HTML document for fullscreen
            const elem = document.documentElement; 

            if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                if (elem.requestFullscreen) { 
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) { 
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { 
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { 
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { 
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { 
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { 
                    document.msExitFullscreen();
                }
            }
        }
        fullscreenButton.addEventListener('click', toggleFullscreen);

        function updateFullscreenButtonText() {
            if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                fullscreenButton.textContent = 'Exit Fullscreen';
            } else {
                fullscreenButton.textContent = 'Toggle Fullscreen';
            }
        }
        ['fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange'].forEach(event => {
            document.addEventListener(event, updateFullscreenButtonText, false);
        });

        // --- Settings Modal Logic ---
        openSettingsButton.addEventListener('click', () => {
            updateSettingsUI(); // Load current values into sliders when opening
            settingsModal.style.display = 'flex'; 
        });

        closeSettingsButton.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });

        window.addEventListener('click', (event) => {
            if (event.target === settingsModal) {
                settingsModal.style.display = 'none';
            }
        });

        // NEW: Event listeners for control position sliders
        joystickXInput.addEventListener('input', (e) => {
            currentControlPositions.joystick.x = parseInt(e.target.value);
            joystickXValueSpan.textContent = e.target.value;
            applyControlPositions();
        });
        joystickYInput.addEventListener('input', (e) => {
            currentControlPositions.joystick.y = parseInt(e.target.value);
            joystickYValueSpan.textContent = e.target.value;
            applyControlPositions();
        });
        shootButtonXInput.addEventListener('input', (e) => {
            currentControlPositions.shootButton.x = parseInt(e.target.value);
            shootButtonXValueSpan.textContent = e.target.value;
            applyControlPositions();
        });
        shootButtonYInput.addEventListener('input', (e) => {
            currentControlPositions.shootButton.y = parseInt(e.target.value);
            shootButtonYValueSpan.textContent = e.target.value;
            applyControlPositions();
        });

        saveControlPositionsButton.addEventListener('click', () => {
            localStorage.setItem('controlPositions', JSON.stringify(currentControlPositions));
            showNotification('Control positions saved!', 'success', 2000);
        });

        resetControlPositionsButton.addEventListener('click', () => {
            localStorage.removeItem('controlPositions');
            currentControlPositions = { ...DEFAULT_CONTROL_POSITIONS }; // Reset to a copy of defaults
            applyControlPositions();
            updateSettingsUI(); // Update sliders to reflect default values
            showNotification('Control positions reset to defaults!', 'info', 2000);
        });


        // --- Player Name Logic ---
        setPlayerNameButton.addEventListener('click', () => {
            let newName = playerNameInput.value.trim();
            if (newName.length === 0) {
                newName = 'Player_' + Math.floor(Math.random() * 1000); 
            }
            newName = newName.substring(0, 12); 
            playerNameInput.value = newName; 

            if (localPlayer.id !== newName) {
                const oldName = localPlayer.id;
                localPlayer.id = newName; 
                localStorage.setItem('playerName', newName);
                showNotification(`Name changed to: ${newName}. Reconnecting...`, 'info');

                if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                    ws.onclose = null; 
                    ws.close(1000, "User changed name"); 
                    setTimeout(connectToServer, 100); 
                } else {
                    connectToServer(); 
                }
            } else {
                showNotification(`Name is already ${newName}.`, 'info', 1500);
            }
        });

        // --- Player Color Logic ---
        setPlayerColorButton.addEventListener('click', () => {
            let newColor = playerColorInput.value;
            if (localPlayer.color !== newColor) {
                const oldColor = localPlayer.color;
                localPlayer.color = newColor;
                localStorage.setItem('playerColor', newColor);
                showNotification(`Your color changed to: ${newColor}. Reconnecting...`, 'info');

                if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                    ws.onclose = null; 
                    ws.close(1000, "User changed color"); 
                    setTimeout(connectToServer, 100); 
                } else {
                    connectToServer(); 
                }
            } else {
                showNotification(`Color is already ${newColor}.`, 'info', 1500);
            }
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateMobileControlsVisibility(); // Set visibility based on device
            applyControlPositions(); // Apply saved or default positions
            updateSettingsUI(); // Initialize settings UI with current values
            connectToServer(); // Connect to game server
        });

        // --- Prevent Page Refresh/Leaving (Optional) ---
        // window.addEventListener('beforeunload', (event) => {
        //     event.preventDefault();
        //     event.returnValue = 'Are you sure you want to leave? Your game progress will be lost.';
        // });
    </script>
</body>
</html>
